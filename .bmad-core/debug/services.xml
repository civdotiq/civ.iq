<?xml version="1.0" encoding="UTF-8"?>
<codebase>
<!-- Generated on 2025-08-17T22:25:34.384Z -->
<!-- Project: civic-intel-hub -->
<file path="ai/summarization.service.ts">
/**
 * Copyright (c) 2019-2025 Mark Sandford
 * Licensed under the MIT License. See LICENSE and NOTICE files.
 */

import { BaseService } from &apos;../api/base.service&apos;;
import logger from &apos;@/lib/logging/simple-logger&apos;;
import { redisService } from &apos;../cache/redis.service&apos;;
import { BillSummaryFallbacks } from &apos;@/features/legislation/services/ai/bill-summary-fallbacks&apos;;

export interface BillSummary {
  billId: string;
  title: string;
  summary: string;
  keyPoints: string[];
  whoItAffects: string[];
  whatItDoes: string;
  whyItMatters: string;
  readingLevel: number;
  confidence: number;
  lastUpdated: string;
  source: &apos;ai-generated&apos; | &apos;congressional-summary&apos; | &apos;manual&apos;;
}

export interface BillSummarizationOptions {
  maxLength?: number;
  includeKeyPoints?: boolean;
  targetReadingLevel?: number;
  useCache?: boolean;
}

export interface MultiFormatSummary {
  brief: string;
  detailed: BillSummary;
  keyPoints: string[];
  plainEnglish: string;
}

class SummarizationService extends BaseService {
  private static instance: SummarizationService;

  private static readonly DEFAULT_OPTIONS: Required&lt;BillSummarizationOptions&gt; = {
    maxLength: 300,
    includeKeyPoints: true,
    targetReadingLevel: 8,
    useCache: true,
  };

  private static readonly READING_LEVEL_PROMPTS: Record&lt;number, string&gt; = {
    8: `Explain this like you&apos;re talking to an 8th grader. Use simple words, short sentences, and everyday examples. Avoid jargon, complex terms, and long explanations. Focus on what this bill actually does and why it matters to regular people.`,
  };

  private constructor() {
    super(&apos;&apos;); // No base URL needed for AI service
  }

  public static getInstance(): SummarizationService {
    if (!SummarizationService.instance) {
      SummarizationService.instance = new SummarizationService();
    }
    return SummarizationService.instance;
  }

  /**
   * Summarize a bill with AI-generated content at 8th grade reading level
   */
  async summarizeBill(
    billText: string,
    billMetadata: {
      number: string;
      title: string;
      congress: number;
      chamber: string;
    },
    options: BillSummarizationOptions = {}
  ): Promise&lt;BillSummary&gt; {
    const opts = { ...SummarizationService.DEFAULT_OPTIONS, ...options };
    const cacheKey = `bill-summary:${billMetadata.number}:${billMetadata.congress}`;

    try {
      // Check cache first
      if (opts.useCache) {
        const cached = await redisService.get&lt;BillSummary&gt;(cacheKey);
        if (cached.success &amp;&amp; cached.data) {
          logger.info(&apos;Bill summary cache hit&apos;, {
            billNumber: billMetadata.number,
            operation: &apos;bill_summarization&apos;,
          });
          return cached.data;
        }
      }

      // Process bill text into manageable chunks
      const processedText = this.preprocessBillText(billText);

      // Generate AI summary
      const summary = await this.generateAISummary(processedText, billMetadata, opts);

      // Validate reading level
      const readingLevel = await this.calculateReadingLevel(summary.summary);

      // If reading level is too high, regenerate with simpler language
      if (readingLevel &gt; opts.targetReadingLevel + 1) {
        logger.warn(&apos;Summary reading level too high, regenerating&apos;, {
          billNumber: billMetadata.number,
          readingLevel,
          target: opts.targetReadingLevel,
        });

        const simplifiedSummary = await this.generateSimplifiedSummary(
          processedText,
          billMetadata,
          opts,
          readingLevel
        );

        summary.summary = simplifiedSummary.summary;
        summary.keyPoints = simplifiedSummary.keyPoints;
        summary.readingLevel = await this.calculateReadingLevel(summary.summary);
      } else {
        summary.readingLevel = readingLevel;
      }

      // Cache the result
      if (opts.useCache) {
        await redisService.set(cacheKey, summary, 24 * 60 * 60); // Cache for 24 hours
      }

      logger.info(&apos;Bill summary generated successfully&apos;, {
        billNumber: billMetadata.number,
        readingLevel: summary.readingLevel,
        confidence: summary.confidence,
        operation: &apos;bill_summarization&apos;,
      });

      return summary;
    } catch (error) {
      logger.error(&apos;Bill summarization failed, attempting fallbacks&apos;, error as Error, {
        billNumber: billMetadata.number,
        operation: &apos;bill_summarization&apos;,
      });

      // Execute comprehensive fallback chain
      const fallbackResult = await BillSummaryFallbacks.executeFallbackChain(
        billText,
        billMetadata,
        error instanceof Error ? error : new Error(&apos;Unknown error&apos;),
        {
          useCongressionalSummary: true,
          useKeywordExtraction: true,
          useSimpleExtraction: true,
        }
      );

      // Log fallback result
      logger.info(&apos;Fallback summary generated&apos;, {
        billNumber: billMetadata.number,
        fallbackMethod: fallbackResult.fallbackMethod,
        success: fallbackResult.success,
        confidence: fallbackResult.summary.confidence,
        operation: &apos;bill_summarization&apos;,
      });

      return fallbackResult.summary;
    }
  }

  /**
   * Get multiple summary formats for different use cases
   */
  async getMultiFormatSummary(
    billText: string,
    billMetadata: { number: string; title: string; congress: number; chamber: string }
  ): Promise&lt;MultiFormatSummary&gt; {
    const detailed = await this.summarizeBill(billText, billMetadata);

    return {
      brief: detailed.whatItDoes,
      detailed,
      keyPoints: detailed.keyPoints,
      plainEnglish: detailed.summary,
    };
  }

  /**
   * Summarize multiple bills in batch
   */
  async summarizeBillsBatch(
    bills: Array&lt;{
      text: string;
      metadata: { number: string; title: string; congress: number; chamber: string };
    }&gt;,
    options: BillSummarizationOptions = {}
  ): Promise&lt;BillSummary[]&gt; {
    const results = await Promise.allSettled(
      bills.map(bill =&gt; this.summarizeBill(bill.text, bill.metadata, options))
    );

    return results.map((result, index) =&gt; {
      if (result.status === &apos;fulfilled&apos;) {
        return result.value;
      } else {
        // Return fallback summary for failed bills
        const bill = bills[index];
        if (bill) {
          return this.generateFallbackSummary(bill.metadata);
        }
        return this.generateFallbackSummary({
          number: &apos;Unknown&apos;,
          title: &apos;Unknown Bill&apos;,
          congress: 0,
          chamber: &apos;Unknown&apos;,
        });
      }
    });
  }

  /**
   * Preprocess bill text to remove formatting and focus on key content
   */
  private preprocessBillText(billText: string): string {
    // Remove common bill formatting artifacts
    let processed = billText
      // Remove line numbers and page numbers
      .replace(/^\s*\d+\s+/gm, &apos;&apos;)
      // Remove excessive whitespace
      .replace(/\s+/g, &apos; &apos;)
      // Remove common legislative boilerplate
      .replace(/Be it enacted by the Senate and House of Representatives[^.]*\./gi, &apos;&apos;)
      // Remove section numbers and subsection markers
      .replace(/\b(SEC|SECTION)\s+\d+\./gi, &apos;&apos;)
      // Remove &quot;(a)&quot; &quot;(b)&quot; etc. subsection markers at start of lines
      .replace(/^\s*\([a-z0-9]+\)\s*/gm, &apos;&apos;)
      // Clean up quotes and formatting
      .replace(/[&quot;&quot;]/g, &apos;&quot;&apos;)
      .replace(/[&apos;&apos;]/g, &quot;&apos;&quot;)
      .trim();

    // Limit to first 10,000 characters to avoid token limits
    if (processed.length &gt; 10000) {
      processed = processed.substring(0, 10000) + &apos;...&apos;;
    }

    return processed;
  }

  /**
   * Generate AI summary using OpenAI or fallback providers
   */
  private async generateAISummary(
    billText: string,
    billMetadata: {
      number: string;
      title: string;
      congress: number;
      chamber: string;
    },
    options: Required&lt;BillSummarizationOptions&gt;
  ): Promise&lt;BillSummary&gt; {
    const prompt = this.buildSummarizationPrompt(billText, billMetadata, options);

    try {
      // Try OpenAI first
      const response = await this.callOpenAI(prompt);
      return this.parseSummaryResponse(response, billMetadata);
    } catch (error) {
      logger.warn(&apos;OpenAI summarization failed, trying fallback&apos;, {
        billNumber: billMetadata.number,
        error: error instanceof Error ? error.message : &apos;Unknown error&apos;,
      });

      // Fallback to simpler rule-based summarization
      return this.generateRuleBasedSummary(billText, billMetadata, options);
    }
  }

  /**
   * Build the prompt for AI summarization
   */
  private buildSummarizationPrompt(
    billText: string,
    billMetadata: { number: string; title: string; congress: number; chamber: string },
    options: Required&lt;BillSummarizationOptions&gt;
  ): string {
    const readingLevelInstructions =
      SummarizationService.READING_LEVEL_PROMPTS[options.targetReadingLevel] ||
      SummarizationService.READING_LEVEL_PROMPTS[8];

    return `
You are an expert at explaining complex government legislation in simple terms.

BILL: ${billMetadata.number} - ${billMetadata.title}

BILL TEXT:
${billText}

INSTRUCTIONS:
${readingLevelInstructions}

Please provide a summary in the following JSON format:
{
  &quot;summary&quot;: &quot;A clear, simple explanation of what this bill does (${options.maxLength} words max)&quot;,
  &quot;keyPoints&quot;: [&quot;3-5 key points in simple language&quot;],
  &quot;whoItAffects&quot;: [&quot;Who this bill affects - regular people, businesses, students, etc.&quot;],
  &quot;whatItDoes&quot;: &quot;One sentence explaining the main action&quot;,
  &quot;whyItMatters&quot;: &quot;Why regular people should care about this bill&quot;,
  &quot;confidence&quot;: 0.95
}

Remember:
- Use words an 8th grader would understand
- Keep sentences short and clear
- Use specific examples when possible
- Avoid political language or bias
- Focus on practical effects on people&apos;s lives
`;
  }

  /**
   * Call OpenAI API for summarization
   */
  private async callOpenAI(prompt: string): Promise&lt;string&gt; {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error(&apos;OpenAI API key not configured&apos;);
    }

    const response = await fetch(&apos;https://api.openai.com/v1/chat/completions&apos;, {
      method: &apos;POST&apos;,
      headers: {
        Authorization: `Bearer ${apiKey}`,
        &apos;Content-Type&apos;: &apos;application/json&apos;,
      },
      body: JSON.stringify({
        model: &apos;gpt-4&apos;,
        messages: [
          {
            role: &apos;system&apos;,
            content:
              &apos;You are an expert at explaining government legislation in simple, accessible language.&apos;,
          },
          {
            role: &apos;user&apos;,
            content: prompt,
          },
        ],
        temperature: 0.3,
        max_tokens: 1000,
      }),
    });

    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.status}`);
    }

    const data = await response.json();
    return data.choices[0].message.content;
  }

  /**
   * Parse AI response into BillSummary format
   */
  private parseSummaryResponse(
    response: string,
    billMetadata: { number: string; title: string; congress: number; chamber: string }
  ): BillSummary {
    try {
      // Try to extract JSON from the response
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error(&apos;No JSON found in response&apos;);
      }

      const parsed = JSON.parse(jsonMatch[0]);

      return {
        billId: `${billMetadata.number}-${billMetadata.congress}`,
        title: billMetadata.title,
        summary: parsed.summary || &apos;&apos;,
        keyPoints: parsed.keyPoints || [],
        whoItAffects: parsed.whoItAffects || [],
        whatItDoes: parsed.whatItDoes || &apos;&apos;,
        whyItMatters: parsed.whyItMatters || &apos;&apos;,
        readingLevel: 8, // Will be calculated separately
        confidence: parsed.confidence || 0.8,
        lastUpdated: new Date().toISOString(),
        source: &apos;ai-generated&apos;,
      };
    } catch (error) {
      throw new Error(`Failed to parse AI response: ${error}`);
    }
  }

  /**
   * Generate simplified summary if reading level is too high
   */
  private async generateSimplifiedSummary(
    billText: string,
    billMetadata: { number: string; title: string; congress: number; chamber: string },
    options: Required&lt;BillSummarizationOptions&gt;,
    currentReadingLevel: number
  ): Promise&lt;{ summary: string; keyPoints: string[] }&gt; {
    const simplificationPrompt = `
The following summary is too complex (reading level ${currentReadingLevel}). 
Please rewrite it to be at an 8th grade reading level:

ORIGINAL BILL TEXT: ${billText.substring(0, 2000)}

Please provide a much simpler version using:
- Very short sentences (10-15 words max)
- Common, everyday words
- No jargon or technical terms
- Simple examples people can relate to

Format as JSON:
{
  &quot;summary&quot;: &quot;Very simple explanation&quot;,
  &quot;keyPoints&quot;: [&quot;Simple point 1&quot;, &quot;Simple point 2&quot;, &quot;Simple point 3&quot;]
}
`;

    try {
      const response = await this.callOpenAI(simplificationPrompt);
      const parsed = JSON.parse(response.match(/\{[\s\S]*\}/)?.[0] || &apos;{}&apos;);
      return {
        summary: parsed.summary || &apos;&apos;,
        keyPoints: parsed.keyPoints || [],
      };
    } catch {
      // Ultimate fallback - super simple rule-based summary
      return {
        summary: `This bill, ${billMetadata.title}, makes changes to current laws. It affects how things work in our government or society.`,
        keyPoints: [
          &apos;This is a new law being considered&apos;,
          &apos;It would change how things currently work&apos;,
          &apos;Congress is voting on whether to pass it&apos;,
        ],
      };
    }
  }

  /**
   * Calculate reading level using Flesch-Kincaid formula
   */
  private async calculateReadingLevel(text: string): Promise&lt;number&gt; {
    // Simple implementation of Flesch-Kincaid Grade Level
    const sentences = text.split(/[.!?]+/).filter(s =&gt; s.trim().length &gt; 0).length;
    const words = text.split(/\s+/).filter(w =&gt; w.length &gt; 0).length;
    const syllables = this.countSyllables(text);

    if (sentences === 0 || words === 0) return 12; // Default to high if can&apos;t calculate

    const avgWordsPerSentence = words / sentences;
    const avgSyllablesPerWord = syllables / words;

    const gradeLevel = 0.39 * avgWordsPerSentence + 11.8 * avgSyllablesPerWord - 15.59;

    return Math.max(1, Math.round(gradeLevel * 10) / 10); // Round to 1 decimal place, min 1
  }

  /**
   * Count syllables in text (simple heuristic)
   */
  private countSyllables(text: string): number {
    const words = text.toLowerCase().split(/\s+/);
    let totalSyllables = 0;

    for (const word of words) {
      // Remove punctuation
      const cleanWord = word.replace(/[^a-z]/g, &apos;&apos;);
      if (cleanWord.length === 0) continue;

      // Count vowel groups
      const vowelGroups = cleanWord.match(/[aeiouy]+/g);
      let syllables = vowelGroups ? vowelGroups.length : 1;

      // Adjust for silent &apos;e&apos;
      if (cleanWord.endsWith(&apos;e&apos;) &amp;&amp; syllables &gt; 1) {
        syllables--;
      }

      // Minimum 1 syllable per word
      totalSyllables += Math.max(1, syllables);
    }

    return totalSyllables;
  }

  /**
   * Generate rule-based summary as fallback
   */
  private generateRuleBasedSummary(
    billText: string,
    billMetadata: { number: string; title: string; congress: number; chamber: string },
    _options: Required&lt;BillSummarizationOptions&gt;
  ): BillSummary {
    // Extract key phrases and create simple summary
    const keyPhrases = this.extractKeyPhrases(billText);

    return {
      billId: `${billMetadata.number}-${billMetadata.congress}`,
      title: billMetadata.title,
      summary: `This bill, called ${billMetadata.title}, makes changes to current laws. ${keyPhrases.slice(0, 2).join(&apos; &apos;)}`,
      keyPoints: [
        &apos;This is new legislation being considered by Congress&apos;,
        &apos;It would change current laws or create new ones&apos;,
        &apos;The full text contains detailed legal language&apos;,
      ],
      whoItAffects: [&apos;American citizens&apos;, &apos;Government agencies&apos;],
      whatItDoes: &apos;Changes or creates laws&apos;,
      whyItMatters: &apos;Laws affect how our government and society work&apos;,
      readingLevel: 8,
      confidence: 0.6,
      lastUpdated: new Date().toISOString(),
      source: &apos;ai-generated&apos;,
    };
  }

  /**
   * Extract key phrases from bill text
   */
  private extractKeyPhrases(text: string): string[] {
    const phrases: string[] = [];

    // Look for common bill patterns
    const patterns = [
      /to amend .{1,100}/gi,
      /to establish .{1,100}/gi,
      /to require .{1,100}/gi,
      /to provide .{1,100}/gi,
      /shall .{1,50}/gi,
    ];

    for (const pattern of patterns) {
      const matches = text.match(pattern);
      if (matches) {
        phrases.push(...matches.slice(0, 2));
      }
    }

    return phrases.map(phrase =&gt; phrase.trim().replace(/\s+/g, &apos; &apos;)).slice(0, 5);
  }

  /**
   * Generate fallback summary when all else fails
   */
  private generateFallbackSummary(billMetadata: {
    number: string;
    title: string;
    congress: number;
    chamber: string;
  }): BillSummary {
    return {
      billId: `${billMetadata.number}-${billMetadata.congress}`,
      title: billMetadata.title,
      summary: `This is ${billMetadata.number}, titled &quot;${billMetadata.title}&quot;. This bill is being considered by Congress. You can read the full text to learn more about what it does.`,
      keyPoints: [
        &apos;This bill is being considered by Congress&apos;,
        &apos;The title gives you an idea of what it covers&apos;,
        &apos;Read the full text for complete details&apos;,
      ],
      whoItAffects: [&apos;To be determined&apos;],
      whatItDoes: &apos;Changes or creates laws&apos;,
      whyItMatters: &apos;All laws can affect citizens&apos;,
      readingLevel: 8,
      confidence: 0.3,
      lastUpdated: new Date().toISOString(),
      source: &apos;ai-generated&apos;,
    };
  }
}

// Export singleton instance
export const summarizationService = SummarizationService.getInstance();

</file>
<file path="api/base.service.ts">
/**
 * Copyright (c) 2019-2025 Mark Sandford
 * Licensed under the MIT License. See LICENSE and NOTICE files.
 */

import logger from &apos;@/lib/logging/simple-logger&apos;;
import { apiConfig } from &apos;@/config&apos;;

export interface RequestOptions extends RequestInit {
  params?: Record&lt;string, string | number | boolean&gt;;
  timeout?: number;
}

export interface ApiResponse&lt;T&gt; {
  data: T;
  status: number;
  headers: Headers;
}

export interface ApiError {
  message: string;
  status?: number;
  code?: string;
  details?: unknown;
}

export abstract class BaseService {
  protected readonly baseURL: string;
  protected readonly defaultHeaders: HeadersInit;
  protected readonly defaultTimeout: number;

  constructor(baseURL: string, defaultHeaders?: HeadersInit, defaultTimeout?: number) {
    this.baseURL = baseURL;
    this.defaultHeaders = {
      ...apiConfig.headers.default,
      ...defaultHeaders,
    };
    this.defaultTimeout = defaultTimeout || apiConfig.timeout;
  }

  /**
   * Main request method with error handling and logging
   */
  protected async request&lt;T&gt;(
    endpoint: string,
    options: RequestOptions = {}
  ): Promise&lt;ApiResponse&lt;T&gt;&gt; {
    const { params, timeout = this.defaultTimeout, ...fetchOptions } = options;

    // Build URL with query parameters
    const url = this.buildUrl(endpoint, params);

    // Merge headers
    const headers = {
      ...this.defaultHeaders,
      ...fetchOptions.headers,
    };

    // Create abort controller for timeout
    const abortController = new AbortController();
    const timeoutId = setTimeout(() =&gt; abortController.abort(), timeout);

    try {
      logger.debug(&apos;API Request&apos;, {
        url,
        method: fetchOptions.method || &apos;GET&apos;,
        headers: this.sanitizeHeaders(headers),
      });

      const response = await fetch(url, {
        ...fetchOptions,
        headers,
        signal: abortController.signal,
      });

      clearTimeout(timeoutId);

      const data = await this.parseResponse&lt;T&gt;(response);

      logger.debug(&apos;API Response&apos;, {
        url,
        status: response.status,
        headers: Object.fromEntries(response.headers.entries()),
      });

      if (!response.ok) {
        throw this.createApiError(response, data);
      }

      return {
        data,
        status: response.status,
        headers: response.headers,
      };
    } catch (error) {
      clearTimeout(timeoutId);

      if (error instanceof Error &amp;&amp; error.name === &apos;AbortError&apos;) {
        const timeoutError = new Error(`Request timeout: ${url}`);
        logger.error(&apos;Request timeout&apos;, timeoutError);
        throw this.createApiError(null, null, &apos;Request timeout&apos;, 408);
      }

      const apiError = error instanceof Error ? error : new Error(&apos;Unknown error&apos;);
      logger.error(`API Request failed: ${url}`, apiError);

      throw error;
    }
  }

  /**
   * Convenience methods for common HTTP verbs
   */
  protected async get&lt;T&gt;(endpoint: string, options?: RequestOptions): Promise&lt;T&gt; {
    const response = await this.request&lt;T&gt;(endpoint, {
      ...options,
      method: &apos;GET&apos;,
    });
    return response.data;
  }

  protected async post&lt;T&gt;(endpoint: string, body?: unknown, options?: RequestOptions): Promise&lt;T&gt; {
    const response = await this.request&lt;T&gt;(endpoint, {
      ...options,
      method: &apos;POST&apos;,
      body: body ? JSON.stringify(body) : undefined,
    });
    return response.data;
  }

  protected async put&lt;T&gt;(endpoint: string, body?: unknown, options?: RequestOptions): Promise&lt;T&gt; {
    const response = await this.request&lt;T&gt;(endpoint, {
      ...options,
      method: &apos;PUT&apos;,
      body: body ? JSON.stringify(body) : undefined,
    });
    return response.data;
  }

  protected async patch&lt;T&gt;(endpoint: string, body?: unknown, options?: RequestOptions): Promise&lt;T&gt; {
    const response = await this.request&lt;T&gt;(endpoint, {
      ...options,
      method: &apos;PATCH&apos;,
      body: body ? JSON.stringify(body) : undefined,
    });
    return response.data;
  }

  protected async delete&lt;T&gt;(endpoint: string, options?: RequestOptions): Promise&lt;T&gt; {
    const response = await this.request&lt;T&gt;(endpoint, {
      ...options,
      method: &apos;DELETE&apos;,
    });
    return response.data;
  }

  /**
   * Build full URL with query parameters
   */
  private buildUrl(endpoint: string, params?: Record&lt;string, string | number | boolean&gt;): string {
    const url = new URL(`${this.baseURL}${endpoint}`, window.location.origin);

    if (params) {
      Object.entries(params).forEach(([key, value]) =&gt; {
        if (value !== undefined &amp;&amp; value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }

    return url.toString();
  }

  /**
   * Parse response based on content type
   */
  private async parseResponse&lt;T&gt;(response: Response): Promise&lt;T&gt; {
    const contentType = response.headers.get(&apos;content-type&apos;);

    if (contentType?.includes(&apos;application/json&apos;)) {
      return response.json();
    }

    if (contentType?.includes(&apos;text/&apos;)) {
      return response.text() as unknown as T;
    }

    // Return blob for other content types
    return response.blob() as unknown as T;
  }

  /**
   * Create standardized API error
   */
  private createApiError(
    response: Response | null,
    data: unknown,
    message?: string,
    status?: number
  ): ApiError {
    const error: ApiError = {
      message: message || response?.statusText || &apos;Unknown error&apos;,
      status: status || response?.status,
    };

    // Try to extract error details from response data
    if (data &amp;&amp; typeof data === &apos;object&apos; &amp;&amp; &apos;error&apos; in data) {
      const errorData = data as { error: string | { message?: string; code?: string } };
      if (typeof errorData.error === &apos;string&apos;) {
        error.message = errorData.error;
      } else if (errorData.error.message) {
        error.message = errorData.error.message;
        error.code = errorData.error.code;
      }
    }

    error.details = data;

    return error;
  }

  /**
   * Remove sensitive headers from logs
   */
  private sanitizeHeaders(headers: HeadersInit): Record&lt;string, string&gt; {
    const sanitized: Record&lt;string, string&gt; = {};
    const sensitiveHeaders = [&apos;authorization&apos;, &apos;cookie&apos;, &apos;x-api-key&apos;];

    Object.entries(headers as Record&lt;string, string&gt;).forEach(([key, value]) =&gt; {
      if (sensitiveHeaders.includes(key.toLowerCase())) {
        sanitized[key] = &apos;[REDACTED]&apos;;
      } else {
        sanitized[key] = value;
      }
    });

    return sanitized;
  }

  /**
   * Retry logic for failed requests using configuration
   */
  protected async withRetry&lt;T&gt;(
    fn: () =&gt; Promise&lt;T&gt;,
    maxRetries = apiConfig.retry.maxAttempts,
    retryDelay = apiConfig.retry.baseDelay
  ): Promise&lt;T&gt; {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt &lt;= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error as Error;

        if (attempt &lt; maxRetries) {
          const delay = Math.min(
            retryDelay * Math.pow(apiConfig.retry.backoffMultiplier, attempt),
            apiConfig.retry.maxDelay
          );

          logger.warn(&apos;Retrying request&apos;, {
            attempt: attempt + 1,
            maxRetries,
            delay,
            error: lastError.message,
          });

          await new Promise(resolve =&gt; setTimeout(resolve, delay));
        }
      }
    }

    throw lastError;
  }
}

</file>
<file path="api/base.ts">
/**
 * Base API service for civic-intel-hub
 * Provides common functionality for all API requests
 */

export interface ApiOptions extends RequestInit {
  timeout?: number;
}

/**
 * Base API request function with error handling and timeout
 */
export async function apiRequest&lt;T = unknown&gt;(
  endpoint: string,
  options: ApiOptions = {}
): Promise&lt;T&gt; {
  const { timeout = 10000, ...fetchOptions } = options;

  // Create abort controller for timeout
  const controller = new AbortController();
  const timeoutId = setTimeout(() =&gt; controller.abort(), timeout);

  try {
    const response = await fetch(`/api${endpoint}`, {
      ...fetchOptions,
      signal: controller.signal,
      headers: {
        &apos;Content-Type&apos;: &apos;application/json&apos;,
        ...fetchOptions.headers,
      },
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      throw new Error(`API Error: ${response.status} ${response.statusText}`);
    }

    return await response.json();
  } catch (error) {
    clearTimeout(timeoutId);

    if (error instanceof Error) {
      if (error.name === &apos;AbortError&apos;) {
        throw new Error(&apos;Request timeout&apos;);
      }
      throw error;
    }

    throw new Error(&apos;Unknown API error&apos;);
  }
}

/**
 * GET request helper
 */
export const apiGet = &lt;T = unknown&gt;(endpoint: string, options?: ApiOptions): Promise&lt;T&gt; =&gt;
  apiRequest&lt;T&gt;(endpoint, { ...options, method: &apos;GET&apos; });

/**
 * POST request helper
 */
export const apiPost = &lt;T = unknown&gt;(
  endpoint: string,
  data?: unknown,
  options?: ApiOptions
): Promise&lt;T&gt; =&gt;
  apiRequest&lt;T&gt;(endpoint, {
    ...options,
    method: &apos;POST&apos;,
    body: data ? JSON.stringify(data) : undefined,
  });

/**
 * PUT request helper
 */
export const apiPut = &lt;T = unknown&gt;(
  endpoint: string,
  data?: unknown,
  options?: ApiOptions
): Promise&lt;T&gt; =&gt;
  apiRequest&lt;T&gt;(endpoint, {
    ...options,
    method: &apos;PUT&apos;,
    body: data ? JSON.stringify(data) : undefined,
  });

/**
 * DELETE request helper
 */
export const apiDelete = &lt;T = unknown&gt;(endpoint: string, options?: ApiOptions): Promise&lt;T&gt; =&gt;
  apiRequest&lt;T&gt;(endpoint, { ...options, method: &apos;DELETE&apos; });

</file>
<file path="api/index.ts">
/**
 * API services index
 * Re-exports all API services for easy importing
 */

export * from &apos;./base&apos;;
export * from &apos;./representatives&apos;;

</file>
<file path="api/news.service.ts">
/**
 * Copyright (c) 2019-2025 Mark Sandford
 * Licensed under the MIT License. See LICENSE and NOTICE files.
 */

import { BaseService } from &apos;./base.service&apos;;
import {
  fetchGDELTNewsWithDeduplication,
  generateOptimizedSearchTerms,
  getGDELTRealTimeStream,
  monitorBreakingNews,
  fetchGDELTTrends,
  fetchGDELTRealTimeEvents,
  normalizeGDELTArticle,
  type GDELTEvent,
  type GDELTTrend,
  type GDELTRealTimeStream,
} from &apos;@/features/news/services/gdelt-api&apos;;
import type {
  DuplicationStats,
  DeduplicationOptions,
} from &apos;@/features/news/utils/news-deduplication&apos;;

export interface NewsArticle {
  url: string;
  title: string;
  source: string;
  publishedDate: string;
  language?: string;
  imageUrl?: string;
  domain: string;
}

export interface NewsSearchOptions {
  maxRecords?: number;
  timeframe?: &apos;15min&apos; | &apos;1hour&apos; | &apos;6hour&apos; | &apos;24hour&apos;;
  deduplication?: Partial&lt;DeduplicationOptions&gt;;
  themes?: string[];
}

export interface BreakingNewsAlert {
  article: NewsArticle;
  urgency: &apos;low&apos; | &apos;medium&apos; | &apos;high&apos;;
  category: &apos;legislation&apos; | &apos;scandal&apos; | &apos;election&apos; | &apos;policy&apos; | &apos;other&apos;;
}

export interface NewsSearchResult {
  articles: NewsArticle[];
  stats: DuplicationStats;
  searchTerms: string[];
}

class NewsService extends BaseService {
  private static instance: NewsService;

  private constructor() {
    super(&apos;/api&apos;);
  }

  public static getInstance(): NewsService {
    if (!NewsService.instance) {
      NewsService.instance = new NewsService();
    }
    return NewsService.instance;
  }

  /**
   * Search for news articles about a representative
   */
  async searchRepresentativeNews(
    representativeName: string,
    state: string,
    district?: string,
    options: NewsSearchOptions = {}
  ): Promise&lt;NewsSearchResult&gt; {
    const { maxRecords = 10, deduplication } = options;

    // Generate optimized search terms
    const searchTerms = generateOptimizedSearchTerms(representativeName, state, district);

    try {
      // Fetch articles using GDELT with deduplication
      const results = await Promise.all(
        searchTerms.map(term =&gt;
          fetchGDELTNewsWithDeduplication(
            term,
            Math.ceil(maxRecords / searchTerms.length),
            deduplication
          )
        )
      );

      // Combine all articles and stats
      const allArticles = results.flatMap(r =&gt; r.articles);
      const combinedStats = results.reduce(
        (acc, r) =&gt; ({
          originalCount: acc.originalCount + r.stats.originalCount,
          duplicatesRemoved: acc.duplicatesRemoved + r.stats.duplicatesRemoved,
          finalCount: acc.finalCount + r.stats.finalCount,
          duplicatesDetected: [...acc.duplicatesDetected, ...r.stats.duplicatesDetected],
        }),
        {
          originalCount: 0,
          duplicatesRemoved: 0,
          finalCount: 0,
          duplicatesDetected: [] as Array&lt;{
            method: string;
            originalIndex: number;
            duplicateIndex: number;
            similarity: number;
          }&gt;,
        }
      );

      // Normalize articles to consistent format
      const articles: NewsArticle[] = allArticles.slice(0, maxRecords).map(article =&gt; {
        const normalized = normalizeGDELTArticle(article);
        return {
          url: article.url,
          title: (normalized as { title: string }).title,
          source: (normalized as { source: string }).source,
          publishedDate: (normalized as { publishedDate: string }).publishedDate,
          language: article.language,
          imageUrl: (normalized as { imageUrl?: string }).imageUrl,
          domain: article.domain,
        };
      });

      return {
        articles,
        stats: combinedStats,
        searchTerms,
      };
    } catch (error) {
      throw this.createServiceError(&apos;Failed to search representative news&apos;, error);
    }
  }

  /**
   * Get real-time news stream for a representative
   */
  async getRealTimeStream(
    representativeName: string,
    state: string,
    district?: string
  ): Promise&lt;GDELTRealTimeStream&gt; {
    try {
      return await getGDELTRealTimeStream(representativeName, state, district);
    } catch (error) {
      throw this.createServiceError(&apos;Failed to get real-time news stream&apos;, error);
    }
  }

  /**
   * Monitor for breaking news about a representative
   */
  async monitorBreakingNews(
    representativeName: string,
    state: string,
    lastCheckTime: string
  ): Promise&lt;BreakingNewsAlert[]&gt; {
    try {
      const alerts = await monitorBreakingNews(representativeName, state, lastCheckTime);
      return alerts.map(alert =&gt; ({
        article: alert.article as NewsArticle,
        urgency: alert.urgency,
        category: alert.category,
      }));
    } catch (error) {
      throw this.createServiceError(&apos;Failed to monitor breaking news&apos;, error);
    }
  }

  /**
   * Get trending political topics
   */
  async getTrends(
    category: &apos;politics&apos; | &apos;government&apos; | &apos;congress&apos; | &apos;elections&apos; = &apos;politics&apos;,
    timeframe: &apos;1hour&apos; | &apos;6hour&apos; | &apos;24hour&apos; = &apos;6hour&apos;
  ): Promise&lt;GDELTTrend[]&gt; {
    try {
      return await fetchGDELTTrends(category, timeframe);
    } catch (error) {
      throw this.createServiceError(&apos;Failed to get news trends&apos;, error);
    }
  }

  /**
   * Get real-time political events
   */
  async getRealTimeEvents(
    keywords: string[],
    timeframe: &apos;15min&apos; | &apos;1hour&apos; | &apos;6hour&apos; | &apos;24hour&apos; = &apos;1hour&apos;
  ): Promise&lt;GDELTEvent[]&gt; {
    try {
      return await fetchGDELTRealTimeEvents(keywords, timeframe);
    } catch (error) {
      throw this.createServiceError(&apos;Failed to get real-time events&apos;, error);
    }
  }

  /**
   * Search news by general query
   */
  async searchNews(query: string, options: NewsSearchOptions = {}): Promise&lt;NewsSearchResult&gt; {
    const { maxRecords = 10, deduplication } = options;

    try {
      const result = await fetchGDELTNewsWithDeduplication(query, maxRecords, deduplication);

      const articles: NewsArticle[] = result.articles.map(article =&gt; {
        const normalized = normalizeGDELTArticle(article);
        return {
          url: article.url,
          title: (normalized as { title: string }).title,
          source: (normalized as { source: string }).source,
          publishedDate: (normalized as { publishedDate: string }).publishedDate,
          language: article.language,
          imageUrl: (normalized as { imageUrl?: string }).imageUrl,
          domain: article.domain,
        };
      });

      return {
        articles,
        stats: result.stats,
        searchTerms: [query],
      };
    } catch (error) {
      throw this.createServiceError(&apos;Failed to search news&apos;, error);
    }
  }

  /**
   * Get news from multiple representatives for comparison
   */
  async getComparativeNews(
    representatives: Array&lt;{
      name: string;
      state: string;
      district?: string;
    }&gt;,
    options: NewsSearchOptions = {}
  ): Promise&lt;Record&lt;string, NewsSearchResult&gt;&gt; {
    const { maxRecords = 5 } = options;

    try {
      const results = await Promise.all(
        representatives.map(async rep =&gt; {
          const result = await this.searchRepresentativeNews(rep.name, rep.state, rep.district, {
            ...options,
            maxRecords,
          });
          return { key: `${rep.name}-${rep.state}`, result };
        })
      );

      return results.reduce(
        (acc, { key, result }) =&gt; {
          acc[key] = result;
          return acc;
        },
        {} as Record&lt;string, NewsSearchResult&gt;
      );
    } catch (error) {
      throw this.createServiceError(&apos;Failed to get comparative news&apos;, error);
    }
  }

  /**
   * Get news summary statistics
   */
  async getNewsSummary(
    representativeName: string,
    state: string,
    district?: string,
    timeframe: &apos;24hour&apos; | &apos;7days&apos; | &apos;30days&apos; = &apos;24hour&apos;
  ): Promise&lt;{
    totalArticles: number;
    sourceCount: number;
    topSources: Array&lt;{ source: string; count: number }&gt;;
    categories: Array&lt;{ category: string; count: number }&gt;;
    timeframe: string;
  }&gt; {
    try {
      // Get extended timeframe for analysis
      const maxRecords = timeframe === &apos;24hour&apos; ? 50 : timeframe === &apos;7days&apos; ? 100 : 200;

      const result = await this.searchRepresentativeNews(representativeName, state, district, {
        maxRecords,
        deduplication: { maxArticlesPerDomain: 10 },
      });

      // Analyze articles
      const sourceMap = new Map&lt;string, number&gt;();
      const categoryMap = new Map&lt;string, number&gt;();

      result.articles.forEach(article =&gt; {
        // Count sources
        const source = article.source;
        sourceMap.set(source, (sourceMap.get(source) || 0) + 1);

        // Simple category detection based on title keywords
        const title = article.title.toLowerCase();
        let category = &apos;other&apos;;

        if (title.includes(&apos;bill&apos;) || title.includes(&apos;vote&apos;) || title.includes(&apos;legislation&apos;)) {
          category = &apos;legislation&apos;;
        } else if (title.includes(&apos;election&apos;) || title.includes(&apos;campaign&apos;)) {
          category = &apos;election&apos;;
        } else if (title.includes(&apos;scandal&apos;) || title.includes(&apos;investigation&apos;)) {
          category = &apos;scandal&apos;;
        } else if (title.includes(&apos;policy&apos;) || title.includes(&apos;budget&apos;)) {
          category = &apos;policy&apos;;
        }

        categoryMap.set(category, (categoryMap.get(category) || 0) + 1);
      });

      const topSources = Array.from(sourceMap.entries())
        .sort((a, b) =&gt; b[1] - a[1])
        .slice(0, 10)
        .map(([source, count]) =&gt; ({ source, count }));

      const categories = Array.from(categoryMap.entries())
        .sort((a, b) =&gt; b[1] - a[1])
        .map(([category, count]) =&gt; ({ category, count }));

      return {
        totalArticles: result.articles.length,
        sourceCount: sourceMap.size,
        topSources,
        categories,
        timeframe,
      };
    } catch (error) {
      throw this.createServiceError(&apos;Failed to get news summary&apos;, error);
    }
  }

  /**
   * Create a standardized service error
   */
  private createServiceError(message: string, originalError: unknown): Error {
    const error = new Error(message);
    if (originalError instanceof Error) {
      error.stack = originalError.stack;
      // TypeScript doesn&apos;t support Error.cause in all targets, so we add it as a property
      (error as Error &amp; { cause?: Error }).cause = originalError;
    }
    return error;
  }
}

// Export singleton instance
export const newsService = NewsService.getInstance();

</file>
<file path="api/representatives.service.ts">
/**
 * Copyright (c) 2019-2025 Mark Sandford
 * Licensed under the MIT License. See LICENSE and NOTICE files.
 */

import { BaseService } from &apos;./base.service&apos;;
import type { Representative } from &apos;@/features/representatives/services/congress-api&apos;;
import { useRepresentativesStore } from &apos;@/store/representatives.store&apos;;
import { apiConfig, getApiUrl } from &apos;@/config&apos;;

export interface RepresentativeFilters {
  state?: string;
  party?: string;
  chamber?: &apos;house&apos; | &apos;senate&apos; | &apos;all&apos;;
  committee?: string;
  searchQuery?: string;
}

export interface RepresentativesBatchRequest {
  bioguideIds: string[];
  includeVotes?: boolean;
  includeFinance?: boolean;
  includeBills?: boolean;
  includeNews?: boolean;
}

export interface VotingRecord {
  voteId: string;
  billId?: string;
  date: string;
  question: string;
  position: &apos;Yea&apos; | &apos;Nay&apos; | &apos;Present&apos; | &apos;Not Voting&apos;;
  result: string;
  chamber: &apos;house&apos; | &apos;senate&apos;;
}

export interface CampaignFinance {
  totalRaised: number;
  totalSpent: number;
  cashOnHand: number;
  lastReportDate: string;
  topContributors: Array&lt;{
    name: string;
    amount: number;
    type: &apos;individual&apos; | &apos;pac&apos; | &apos;corporate&apos;;
  }&gt;;
}

export interface PartyAlignment {
  partyLineVoting: number;
  bipartisanBills: number;
  totalVotes: number;
  alignmentTrend: &apos;increasing&apos; | &apos;decreasing&apos; | &apos;stable&apos;;
}

class RepresentativesService extends BaseService {
  private static instance: RepresentativesService;

  private constructor() {
    super(getApiUrl(&apos;&apos;));
  }

  public static getInstance(): RepresentativesService {
    if (!RepresentativesService.instance) {
      RepresentativesService.instance = new RepresentativesService();
    }
    return RepresentativesService.instance;
  }

  /**
   * Get all representatives with optional filters
   */
  async getAll(filters?: RepresentativeFilters): Promise&lt;Representative[]&gt; {
    return this.get&lt;Representative[]&gt;(apiConfig.endpoints.representatives, {
      params: filters as Record&lt;string, string&gt;,
    });
  }

  /**
   * Get representatives by ZIP code
   */
  async getByZipCode(zipCode: string): Promise&lt;Representative[]&gt; {
    return this.get&lt;Representative[]&gt;(apiConfig.endpoints.representatives, {
      params: { zip: zipCode },
    });
  }

  /**
   * Get a single representative by bioguide ID
   */
  async getById(bioguideId: string): Promise&lt;Representative&gt; {
    return this.get&lt;Representative&gt;(`${apiConfig.endpoints.representative}/${bioguideId}`);
  }

  /**
   * Get voting records for a representative
   */
  async getVotingRecords(
    bioguideId: string,
    options?: {
      congress?: number;
      limit?: number;
      offset?: number;
    }
  ): Promise&lt;VotingRecord[]&gt; {
    return this.get&lt;VotingRecord[]&gt;(`${apiConfig.endpoints.representative}/${bioguideId}/votes`, {
      params: options as Record&lt;string, string | number&gt;,
    });
  }

  /**
   * Get campaign finance data for a representative
   */
  async getCampaignFinance(bioguideId: string): Promise&lt;CampaignFinance&gt; {
    return this.get&lt;CampaignFinance&gt;(`${apiConfig.endpoints.representative}/${bioguideId}/finance`);
  }

  /**
   * Get bills sponsored/cosponsored by a representative
   */
  async getBills(
    bioguideId: string,
    options?: {
      type?: &apos;sponsored&apos; | &apos;cosponsored&apos; | &apos;all&apos;;
      congress?: number;
      limit?: number;
    }
  ): Promise&lt;Array&lt;{ id: string; title: string; status: string }&gt;&gt; {
    return this.get&lt;Array&lt;{ id: string; title: string; status: string }&gt;&gt;(
      `${apiConfig.endpoints.representative}/${bioguideId}/bills`,
      {
        params: options as Record&lt;string, string | number&gt;,
      }
    );
  }

  /**
   * Get news articles about a representative
   */
  async getNews(
    bioguideId: string,
    options?: {
      limit?: number;
      offset?: number;
      theme?: string;
    }
  ): Promise&lt;Array&lt;{ title: string; url: string; date: string; source: string }&gt;&gt; {
    return this.get&lt;Array&lt;{ title: string; url: string; date: string; source: string }&gt;&gt;(
      `${apiConfig.endpoints.representative}/${bioguideId}/news`,
      {
        params: options as Record&lt;string, string | number&gt;,
      }
    );
  }

  /**
   * Get party alignment analysis for a representative
   */
  async getPartyAlignment(bioguideId: string): Promise&lt;PartyAlignment&gt; {
    return this.get&lt;PartyAlignment&gt;(
      `${apiConfig.endpoints.representative}/${bioguideId}/party-alignment`
    );
  }

  /**
   * Batch fetch multiple data points for multiple representatives
   */
  async getBatch(request: RepresentativesBatchRequest): Promise&lt;Record&lt;string, unknown&gt;&gt; {
    return this.post&lt;Record&lt;string, unknown&gt;&gt;(
      `${apiConfig.endpoints.representative}/batch`,
      request
    );
  }

  /**
   * Search representatives by query
   */
  async search(query: string, filters?: RepresentativeFilters): Promise&lt;Representative[]&gt; {
    return this.get&lt;Representative[]&gt;(apiConfig.endpoints.search, {
      params: {
        q: query,
        ...filters,
      } as Record&lt;string, string&gt;,
    });
  }

  /**
   * Get committee members
   */
  async getCommitteeMembers(committeeId: string): Promise&lt;Representative[]&gt; {
    return this.get&lt;Representative[]&gt;(`/api/v1/committee/${committeeId}/members`);
  }

  /**
   * Compare multiple representatives
   */
  async compare(bioguideIds: string[]): Promise&lt;{
    representatives: Representative[];
    comparison: {
      votingSimilarity: Record&lt;string, number&gt;;
      billCosponsorship: Record&lt;string, number&gt;;
      partyAlignment: Record&lt;string, number&gt;;
    };
  }&gt; {
    return this.post(`${apiConfig.endpoints.representatives}/compare`, { bioguideIds });
  }

  /**
   * Sync with Zustand store
   */
  async syncWithStore(filters?: RepresentativeFilters): Promise&lt;void&gt; {
    const store = useRepresentativesStore.getState();
    store.setLoading(true);

    try {
      const representatives = await this.getAll(filters);
      store.setRepresentatives(representatives);
      store.setError(null);
    } catch (error) {
      store.setError(error instanceof Error ? error.message : &apos;Failed to fetch representatives&apos;);
      throw error;
    } finally {
      store.setLoading(false);
    }
  }

  /**
   * Get representative photo with fallbacks
   */
  async getPhoto(bioguideId: string): Promise&lt;string&gt; {
    try {
      const response = await this.get&lt;{ url: string }&gt;(
        `/api/v1/representative-photo/${bioguideId}`
      );
      return response.url;
    } catch {
      // Return default avatar on error
      return &apos;/images/default-avatar.png&apos;;
    }
  }

  /**
   * Get district information
   */
  async getDistrict(
    state: string,
    district: string
  ): Promise&lt;{
    id: string;
    state: string;
    number: string;
    population: number;
    demographics: Record&lt;string, unknown&gt;;
  }&gt; {
    return this.get(`${apiConfig.endpoints.districts}/${state}-${district}`);
  }

  /**
   * Get all districts for a state
   */
  async getStateDistricts(state: string): Promise&lt;
    Array&lt;{
      id: string;
      number: string;
      representative?: Representative;
    }&gt;
  &gt; {
    return this.get(`${apiConfig.endpoints.districts}/state/${state}`);
  }
}

// Export singleton instance
export const representativesService = RepresentativesService.getInstance();

</file>
<file path="api/representatives.ts">
/**
 * Representatives API service
 * Handles all representative-related API calls
 */

import { apiGet, apiPost } from &apos;./base&apos;;

export interface RepresentativeFilters {
  zip?: string;
  state?: string;
  party?: string;
  chamber?: &apos;House&apos; | &apos;Senate&apos;;
  district?: string;
}

export interface Representative {
  bioguideId: string;
  name: string;
  party: string;
  state: string;
  district?: string;
  chamber: &apos;House&apos; | &apos;Senate&apos;;
}

export interface RepresentativesResponse {
  representatives: Representative[];
  total: number;
  cached: boolean;
}

/**
 * Get representatives by ZIP code
 */
export const getRepresentativesByZip = (zip: string) =&gt;
  apiGet&lt;RepresentativesResponse&gt;(`/representatives?zip=${zip}`);

/**
 * Get representatives with filters
 */
export const getRepresentatives = (filters?: RepresentativeFilters) =&gt;
  apiPost&lt;RepresentativesResponse&gt;(&apos;/representatives&apos;, filters);

/**
 * Get individual representative details
 */
export const getRepresentative = (bioguideId: string) =&gt;
  apiGet&lt;Representative&gt;(`/representative/${bioguideId}`);

/**
 * Get representative voting records
 */
export const getRepresentativeVotes = (bioguideId: string, limit = 20) =&gt;
  apiGet(`/representative/${bioguideId}/votes?limit=${limit}`);

/**
 * Get representative bills
 */
export const getRepresentativeBills = (bioguideId: string, limit = 20) =&gt;
  apiGet(`/representative/${bioguideId}/bills?limit=${limit}`);

/**
 * Get representative campaign finance data
 */
export const getRepresentativeFinance = (bioguideId: string) =&gt;
  apiGet(`/representative/${bioguideId}/finance`);

/**
 * Get representative news
 */
export const getRepresentativeNews = (bioguideId: string, limit = 10) =&gt;
  apiGet(`/representative/${bioguideId}/news?limit=${limit}`);

/**
 * Get representative party alignment
 */
export const getRepresentativePartyAlignment = (bioguideId: string) =&gt;
  apiGet(`/representative/${bioguideId}/party-alignment`);

</file>
<file path="cache/index.ts">
// Export cache services

export { govCache, cachedFetch } from &apos;./simple-government-cache&apos;;
export type { CacheOptions, CacheStats } from &apos;./simple-government-cache&apos;;

</file>
<file path="cache/redis.service.ts">
/**
 * Copyright (c) 2019-2025 Mark Sandford
 * Licensed under the MIT License. See LICENSE and NOTICE files.
 */

import Redis from &apos;ioredis&apos;;
import logger from &apos;@/lib/logging/simple-logger&apos;;
import { monitorCache } from &apos;@/lib/monitoring/telemetry&apos;;

interface CacheConfig {
  host: string;
  port: number;
  password?: string;
  db?: number;
  maxRetriesPerRequest?: number;
  lazyConnect?: boolean;
  keyPrefix?: string;
}

interface CacheEntry&lt;T = unknown&gt; {
  data: T;
  timestamp: number;
  ttl: number;
}

export interface CacheOperationResult&lt;T = unknown&gt; {
  success: boolean;
  data?: T;
  error?: string;
  source?: &apos;redis&apos; | &apos;fallback&apos;;
}

class RedisService {
  private static instance: RedisService;
  private client: Redis;
  private fallbackCache: Map&lt;string, CacheEntry&gt;;
  private isConnected: boolean = false;
  private readonly keyPrefix: string;

  private constructor(config?: Partial&lt;CacheConfig&gt;) {
    this.keyPrefix = config?.keyPrefix || &apos;civiq:&apos;;
    this.fallbackCache = new Map();

    // Default Redis configuration
    const defaultConfig: CacheConfig = {
      host: process.env.REDIS_HOST || &apos;localhost&apos;,
      port: parseInt(process.env.REDIS_PORT || &apos;6379&apos;),
      password: process.env.REDIS_PASSWORD,
      db: parseInt(process.env.REDIS_DB || &apos;0&apos;),
      maxRetriesPerRequest: 3,
      lazyConnect: true,
      keyPrefix: this.keyPrefix,
    };

    const finalConfig = { ...defaultConfig, ...config };

    // Create Redis client
    this.client = new Redis({
      host: finalConfig.host,
      port: finalConfig.port,
      password: finalConfig.password,
      db: finalConfig.db,
      maxRetriesPerRequest: finalConfig.maxRetriesPerRequest,
      lazyConnect: finalConfig.lazyConnect,
      keyPrefix: finalConfig.keyPrefix,

      // Connection retry strategy
      retryStrategy: times =&gt; {
        const delay = Math.min(times * 50, 2000);
        logger.warn(&apos;Redis connection retry&apos;, { attempt: times, delay });
        return delay;
      },

      // Reconnect on error
      reconnectOnError: err =&gt; {
        const targetError = &apos;READONLY&apos;;
        return err.message.includes(targetError);
      },
    });

    this.setupEventHandlers();
    this.startCleanupTask();
  }

  public static getInstance(config?: Partial&lt;CacheConfig&gt;): RedisService {
    if (!RedisService.instance) {
      RedisService.instance = new RedisService(config);
    }
    return RedisService.instance;
  }

  private setupEventHandlers(): void {
    this.client.on(&apos;connect&apos;, () =&gt; {
      this.isConnected = true;
      logger.info(&apos;Redis connected successfully&apos;);
    });

    this.client.on(&apos;ready&apos;, () =&gt; {
      logger.info(&apos;Redis client ready&apos;);
    });

    this.client.on(&apos;error&apos;, error =&gt; {
      this.isConnected = false;
      logger.error(&apos;Redis connection error&apos;, error, {
        redisHost: process.env.REDIS_HOST,
        redisPort: process.env.REDIS_PORT,
      });
    });

    this.client.on(&apos;close&apos;, () =&gt; {
      this.isConnected = false;
      logger.warn(&apos;Redis connection closed&apos;);
    });

    this.client.on(&apos;reconnecting&apos;, () =&gt; {
      logger.info(&apos;Redis reconnecting&apos;);
    });
  }

  private startCleanupTask(): void {
    // Clean up in-memory fallback cache every 5 minutes
    setInterval(
      () =&gt; {
        this.cleanupFallbackCache();
      },
      5 * 60 * 1000
    );
  }

  private cleanupFallbackCache(): void {
    const now = Date.now();
    let cleaned = 0;

    for (const [key, entry] of this.fallbackCache.entries()) {
      if (now - entry.timestamp &gt; entry.ttl) {
        this.fallbackCache.delete(key);
        cleaned++;
      }
    }

    if (cleaned &gt; 0) {
      logger.debug(&apos;Cleaned up fallback cache&apos;, { entriesRemoved: cleaned });
    }
  }

  private getFallbackKey(key: string): string {
    return `${this.keyPrefix}${key}`;
  }

  /**
   * Get a value from cache
   */
  async get&lt;T = unknown&gt;(key: string): Promise&lt;CacheOperationResult&lt;T&gt;&gt; {
    const monitor = monitorCache(&apos;get&apos;, key);

    try {
      if (this.isConnected) {
        const value = await this.client.get(key);

        if (value) {
          monitor.end(true);
          logger.debug(&apos;Cache hit&apos;, { key });
          return {
            success: true,
            data: JSON.parse(value),
            source: &apos;redis&apos;,
          };
        } else {
          monitor.end(false);
          logger.debug(&apos;Cache miss&apos;, { key });
          return {
            success: true,
            data: undefined,
            source: &apos;redis&apos;,
          };
        }
      } else {
        // Use fallback cache
        const fallbackKey = this.getFallbackKey(key);
        const entry = this.fallbackCache.get(fallbackKey);

        if (entry &amp;&amp; Date.now() - entry.timestamp &lt; entry.ttl) {
          monitor.end(true);
          logger.debug(&apos;Cache hit&apos;, { key, source: &apos;fallback&apos; });
          return {
            success: true,
            data: entry.data as T,
            source: &apos;fallback&apos;,
          };
        } else {
          if (entry) {
            this.fallbackCache.delete(fallbackKey);
          }
          monitor.end(false);
          logger.debug(&apos;Cache miss&apos;, { key, source: &apos;fallback&apos; });
          return {
            success: true,
            data: undefined,
            source: &apos;fallback&apos;,
          };
        }
      }
    } catch (error) {
      monitor.end(false, error as Error);
      logger.error(&apos;Cache operation error&apos;, error as Error, { key, operation: &apos;get&apos; });

      // Try fallback cache on Redis error
      const fallbackKey = this.getFallbackKey(key);
      const entry = this.fallbackCache.get(fallbackKey);

      if (entry &amp;&amp; Date.now() - entry.timestamp &lt; entry.ttl) {
        return {
          success: true,
          data: entry.data as T,
          source: &apos;fallback&apos;,
        };
      }

      return {
        success: false,
        error: (error as Error).message,
      };
    }
  }

  /**
   * Set a value in cache
   */
  async set&lt;T = unknown&gt;(
    key: string,
    value: T,
    ttlSeconds: number = 3600
  ): Promise&lt;CacheOperationResult&gt; {
    const monitor = monitorCache(&apos;set&apos;, key);

    try {
      const serializedValue = JSON.stringify(value);

      if (this.isConnected) {
        await this.client.setex(key, ttlSeconds, serializedValue);
        monitor.end();
        logger.debug(&apos;Cache set&apos;, { key, ttl: ttlSeconds });
        return {
          success: true,
          source: &apos;redis&apos;,
        };
      } else {
        // Use fallback cache
        const fallbackKey = this.getFallbackKey(key);
        this.fallbackCache.set(fallbackKey, {
          data: value,
          timestamp: Date.now(),
          ttl: ttlSeconds * 1000, // Convert to milliseconds
        });
        monitor.end();
        logger.debug(&apos;Cache set&apos;, { key, ttl: ttlSeconds, source: &apos;fallback&apos; });
        return {
          success: true,
          source: &apos;fallback&apos;,
        };
      }
    } catch (error) {
      monitor.end(false, error as Error);
      logger.error(&apos;Cache operation error&apos;, error as Error, {
        key,
        operation: &apos;set&apos;,
      });

      // Try fallback cache on Redis error
      try {
        const fallbackKey = this.getFallbackKey(key);
        this.fallbackCache.set(fallbackKey, {
          data: value,
          timestamp: Date.now(),
          ttl: ttlSeconds * 1000,
        });
        return {
          success: true,
          source: &apos;fallback&apos;,
        };
      } catch {
        return {
          success: false,
          error: (error as Error).message,
        };
      }
    }
  }

  /**
   * Delete a value from cache
   */
  async delete(key: string): Promise&lt;CacheOperationResult&lt;boolean&gt;&gt; {
    const monitor = monitorCache(&apos;delete&apos;, key);

    try {
      if (this.isConnected) {
        const result = await this.client.del(key);
        monitor.end();
        logger.debug(&apos;Cache delete&apos;, { key, deleted: result &gt; 0 });
        return {
          success: true,
          data: result &gt; 0,
          source: &apos;redis&apos;,
        };
      } else {
        // Use fallback cache
        const fallbackKey = this.getFallbackKey(key);
        const existed = this.fallbackCache.has(fallbackKey);
        this.fallbackCache.delete(fallbackKey);
        monitor.end();
        logger.debug(&apos;Cache delete&apos;, { key, deleted: existed, source: &apos;fallback&apos; });
        return {
          success: true,
          data: existed,
          source: &apos;fallback&apos;,
        };
      }
    } catch (error) {
      monitor.end(false, error as Error);
      logger.error(&apos;Cache operation error&apos;, error as Error, {
        key,
        operation: &apos;delete&apos;,
      });

      // Try fallback cache on Redis error
      const fallbackKey = this.getFallbackKey(key);
      const existed = this.fallbackCache.has(fallbackKey);
      this.fallbackCache.delete(fallbackKey);
      return {
        success: true,
        data: existed,
        source: &apos;fallback&apos;,
      };
    }
  }

  /**
   * Flush all cache data
   */
  async flush(): Promise&lt;CacheOperationResult&gt; {
    try {
      if (this.isConnected) {
        await this.client.flushdb();
        logger.info(&apos;Redis cache flushed&apos;);
      }

      // Clear fallback cache too
      this.fallbackCache.clear();
      logger.info(&apos;Fallback cache cleared&apos;);

      return {
        success: true,
      };
    } catch (error) {
      logger.error(&apos;Failed to flush cache&apos;, error as Error);

      // Clear fallback cache even if Redis fails
      this.fallbackCache.clear();
      return {
        success: false,
        error: (error as Error).message,
      };
    }
  }

  /**
   * Check if a key exists in cache
   */
  async exists(key: string): Promise&lt;CacheOperationResult&lt;boolean&gt;&gt; {
    try {
      if (this.isConnected) {
        const result = await this.client.exists(key);
        return {
          success: true,
          data: result === 1,
          source: &apos;redis&apos;,
        };
      } else {
        const fallbackKey = this.getFallbackKey(key);
        const entry = this.fallbackCache.get(fallbackKey);
        const exists = entry !== undefined &amp;&amp; Date.now() - entry.timestamp &lt; entry.ttl;
        return {
          success: true,
          data: exists,
          source: &apos;fallback&apos;,
        };
      }
    } catch (error) {
      logger.error(&apos;Cache operation error&apos;, error as Error, {
        key,
        operation: &apos;exists&apos;,
      });

      // Check fallback cache
      const fallbackKey = this.getFallbackKey(key);
      const entry = this.fallbackCache.get(fallbackKey);
      const exists = entry !== undefined &amp;&amp; Date.now() - entry.timestamp &lt; entry.ttl;
      return {
        success: true,
        data: exists,
        source: &apos;fallback&apos;,
      };
    }
  }

  /**
   * Get keys matching a pattern
   */
  async keys(pattern: string): Promise&lt;CacheOperationResult&lt;string[]&gt;&gt; {
    try {
      if (this.isConnected) {
        const keys = await this.client.keys(pattern);
        return {
          success: true,
          data: keys,
          source: &apos;redis&apos;,
        };
      } else {
        // Search fallback cache
        const regex = new RegExp(pattern.replace(/\*/g, &apos;.*&apos;));
        const keys = Array.from(this.fallbackCache.keys()).filter(key =&gt; regex.test(key));
        return {
          success: true,
          data: keys,
          source: &apos;fallback&apos;,
        };
      }
    } catch (error) {
      logger.error(&apos;Failed to get keys&apos;, error as Error, { pattern });
      return {
        success: false,
        error: (error as Error).message,
      };
    }
  }

  /**
   * Retry logic for failed requests
   */
  private async withRetry&lt;T&gt;(fn: () =&gt; Promise&lt;T&gt;, maxRetries = 3, retryDelay = 1000): Promise&lt;T&gt; {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt &lt;= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error as Error;

        if (attempt &lt; maxRetries) {
          logger.warn(&apos;Retrying cache operation&apos;, {
            attempt: attempt + 1,
            maxRetries,
            error: lastError.message,
          });

          await new Promise(resolve =&gt; setTimeout(resolve, retryDelay * Math.pow(2, attempt)));
        }
      }
    }

    throw lastError;
  }

  /**
   * Get cache with automatic retry and fallback
   */
  async getWithRetry&lt;T = unknown&gt;(key: string, maxRetries = 3): Promise&lt;T | null&gt; {
    return this.withRetry(
      async () =&gt; {
        const result = await this.get&lt;T&gt;(key);
        if (!result.success) {
          throw new Error(result.error || &apos;Cache operation failed&apos;);
        }
        return result.data || null;
      },
      maxRetries,
      1000
    );
  }

  /**
   * Set cache with automatic retry and fallback
   */
  async setWithRetry&lt;T = unknown&gt;(
    key: string,
    value: T,
    ttlSeconds = 3600,
    maxRetries = 3
  ): Promise&lt;boolean&gt; {
    try {
      const result = await this.withRetry(
        async () =&gt; {
          const result = await this.set(key, value, ttlSeconds);
          if (!result.success) {
            throw new Error(result.error || &apos;Cache operation failed&apos;);
          }
          return result.success;
        },
        maxRetries,
        1000
      );
      return result;
    } catch {
      return false;
    }
  }

  /**
   * Get cache status and metrics
   */
  getStatus(): {
    isConnected: boolean;
    fallbackCacheSize: number;
    redisStatus: string;
    keyPrefix: string;
  } {
    return {
      isConnected: this.isConnected,
      fallbackCacheSize: this.fallbackCache.size,
      redisStatus: this.client.status,
      keyPrefix: this.keyPrefix,
    };
  }

  /**
   * Disconnect from Redis
   */
  async disconnect(): Promise&lt;void&gt; {
    try {
      await this.client.quit();
      logger.info(&apos;Redis client disconnected&apos;);
    } catch (error) {
      logger.error(&apos;Error disconnecting Redis&apos;, error as Error);
    }
  }

  /**
   * Get direct access to Redis client (for advanced operations)
   */
  getClient(): Redis {
    return this.client;
  }

  /**
   * Batch operations for better performance
   */
  async batch(
    operations: Array&lt;{
      operation: &apos;get&apos; | &apos;set&apos; | &apos;del&apos;;
      key: string;
      value?: unknown;
      ttl?: number;
    }&gt;
  ): Promise&lt;CacheOperationResult[]&gt; {
    const results: CacheOperationResult[] = [];

    if (this.isConnected) {
      // Use Redis pipeline for batch operations
      const pipeline = this.client.pipeline();

      operations.forEach(op =&gt; {
        switch (op.operation) {
          case &apos;get&apos;:
            pipeline.get(op.key);
            break;
          case &apos;set&apos;:
            if (op.value !== undefined) {
              pipeline.setex(op.key, op.ttl || 3600, JSON.stringify(op.value));
            }
            break;
          case &apos;del&apos;:
            pipeline.del(op.key);
            break;
        }
      });

      try {
        const pipelineResults = await pipeline.exec();

        operations.forEach((op, index) =&gt; {
          const pipelineResult = pipelineResults?.[index];
          if (pipelineResult &amp;&amp; !pipelineResult[0]) {
            // No error
            if (op.operation === &apos;get&apos;) {
              results.push({
                success: true,
                data: pipelineResult[1] ? JSON.parse(pipelineResult[1] as string) : undefined,
                source: &apos;redis&apos;,
              });
            } else {
              results.push({
                success: true,
                source: &apos;redis&apos;,
              });
            }
          } else {
            results.push({
              success: false,
              error: pipelineResult?.[0]?.message || &apos;Pipeline operation failed&apos;,
            });
          }
        });
      } catch {
        // Fall back to individual operations
        for (const op of operations) {
          try {
            if (op.operation === &apos;get&apos;) {
              results.push(await this.get(op.key));
            } else if (op.operation === &apos;set&apos; &amp;&amp; op.value !== undefined) {
              results.push(await this.set(op.key, op.value, op.ttl));
            } else if (op.operation === &apos;del&apos;) {
              results.push(await this.delete(op.key));
            }
          } catch (opError) {
            results.push({
              success: false,
              error: (opError as Error).message,
            });
          }
        }
      }
    } else {
      // Use fallback cache for batch operations
      for (const op of operations) {
        try {
          if (op.operation === &apos;get&apos;) {
            results.push(await this.get(op.key));
          } else if (op.operation === &apos;set&apos; &amp;&amp; op.value !== undefined) {
            results.push(await this.set(op.key, op.value, op.ttl));
          } else if (op.operation === &apos;del&apos;) {
            results.push(await this.delete(op.key));
          }
        } catch (error) {
          results.push({
            success: false,
            error: (error as Error).message,
          });
        }
      }
    }

    return results;
  }
}

// Export singleton instance
export const redisService = RedisService.getInstance();
export default RedisService;

</file>
<file path="cache/simple-government-cache.ts">
// src/services/cache/simple-government-cache.ts
// START HERE - This won&apos;t break anything and provides immediate benefits

/**
 * Simple in-memory cache for government API data
 * No external dependencies required - works immediately
 * Upgrade to Redis later for production
 */

interface CacheEntry&lt;T&gt; {
  data: T;
  timestamp: number;
  source: string;
  expiresAt: number;
}

class SimpleGovernmentCache {
  private cache = new Map&lt;string, CacheEntry&lt;any&gt;&gt;();
  private readonly DEFAULT_TTL = 30 * 60 * 1000; // 30 minutes

  // Different TTLs for different data types (in milliseconds)
  private readonly ttls = {
    representatives: 30 * 60 * 1000, // 30 minutes
    voting: 15 * 60 * 1000, // 15 minutes
    finance: 24 * 60 * 60 * 1000, // 24 hours
    districts: 7 * 24 * 60 * 60 * 1000, // 7 days
    committees: 60 * 60 * 1000, // 1 hour
  };

  /**
   * Get cached data if available and not expired
   */
  get&lt;T&gt;(key: string): T | null {
    const entry = this.cache.get(key);

    if (!entry) {
      console.log(`[Cache MISS] ${key}`);
      return null;
    }

    if (Date.now() &gt; entry.expiresAt) {
      console.log(`[Cache EXPIRED] ${key}`);
      this.cache.delete(key);
      return null;
    }

    console.log(`[Cache HIT] ${key} (source: ${entry.source})`);
    return entry.data;
  }

  /**
   * Store data in cache with TTL
   */
  set&lt;T&gt;(
    key: string,
    data: T,
    options?: {
      ttl?: number;
      source?: string;
      dataType?: keyof typeof SimpleGovernmentCache.prototype.ttls;
    }
  ): void {
    const ttl =
      options?.ttl ||
      (options?.dataType ? this.ttls[options.dataType] : undefined) ||
      this.DEFAULT_TTL;

    const entry: CacheEntry&lt;T&gt; = {
      data,
      timestamp: Date.now(),
      source: options?.source || &apos;unknown&apos;,
      expiresAt: Date.now() + ttl,
    };

    this.cache.set(key, entry);
    console.log(`[Cache SET] ${key} (TTL: ${ttl / 1000}s, source: ${entry.source})`);
  }

  /**
   * Clear specific keys or entire cache
   */
  clear(pattern?: string): void {
    if (!pattern) {
      const size = this.cache.size;
      this.cache.clear();
      console.log(`[Cache CLEAR] Removed all ${size} entries`);
      return;
    }

    let cleared = 0;
    for (const key of this.cache.keys()) {
      if (key.includes(pattern)) {
        this.cache.delete(key);
        cleared++;
      }
    }
    console.log(`[Cache CLEAR] Removed ${cleared} entries matching &quot;${pattern}&quot;`);
  }

  /**
   * Get cache statistics
   */
  getStats() {
    const now = Date.now();
    let expired = 0;
    let active = 0;
    let oldestEntry: number | null = null;
    let newestEntry: number | null = null;

    for (const entry of this.cache.values()) {
      if (entry.expiresAt &lt; now) {
        expired++;
      } else {
        active++;
      }

      if (!oldestEntry || entry.timestamp &lt; oldestEntry) {
        oldestEntry = entry.timestamp;
      }
      if (!newestEntry || entry.timestamp &gt; newestEntry) {
        newestEntry = entry.timestamp;
      }
    }

    return {
      totalEntries: this.cache.size,
      activeEntries: active,
      expiredEntries: expired,
      oldestEntry: oldestEntry ? new Date(oldestEntry).toISOString() : null,
      newestEntry: newestEntry ? new Date(newestEntry).toISOString() : null,
      memorySizeEstimate: JSON.stringify(Array.from(this.cache.entries())).length,
    };
  }

  /**
   * Clean up expired entries (call periodically)
   */
  cleanup(): void {
    const now = Date.now();
    let removed = 0;

    for (const [key, entry] of this.cache.entries()) {
      if (entry.expiresAt &lt; now) {
        this.cache.delete(key);
        removed++;
      }
    }

    if (removed &gt; 0) {
      console.log(`[Cache CLEANUP] Removed ${removed} expired entries`);
    }
  }
}

// Create singleton instance
export const govCache = new SimpleGovernmentCache();

// Run cleanup every 5 minutes
if (typeof window === &apos;undefined&apos;) {
  // Only on server
  setInterval(() =&gt; govCache.cleanup(), 5 * 60 * 1000);
}

/**
 * Generic cached fetch helper
 */
export async function cachedFetch&lt;T&gt;(
  cacheKey: string,
  fetcher: () =&gt; Promise&lt;T&gt;,
  options?: {
    ttl?: number;
    source?: string;
    dataType?: keyof (typeof govCache)[&apos;ttls&apos;];
  }
): Promise&lt;T&gt; {
  // Try cache first
  const cached = govCache.get&lt;T&gt;(cacheKey);
  if (cached) return cached;

  // Fetch fresh data
  const fresh = await fetcher();

  // Cache for next time
  govCache.set(cacheKey, fresh, options);

  return fresh;
}

// Type definitions for better TypeScript support
export interface CacheOptions {
  ttl?: number;
  source?: string;
  dataType?: &apos;representatives&apos; | &apos;voting&apos; | &apos;finance&apos; | &apos;districts&apos; | &apos;committees&apos;;
}

export interface CacheStats {
  totalEntries: number;
  activeEntries: number;
  expiredEntries: number;
  oldestEntry: string | null;
  newestEntry: string | null;
  memorySizeEstimate: number;
}

</file>
<file path="district-lookup.ts">
/**
 * District Lookup Service
 *
 * Provides accurate lat/lng to congressional district lookup functionality
 * using Census TIGER/Line data and geometric calculations.
 */

import {
  districtBoundaryService,
  type DistrictBoundary,
} from &apos;@/lib/helpers/district-boundary-utils&apos;;
import logger from &apos;@/lib/logging/simple-logger&apos;;

interface GeocodeResult {
  latitude: number;
  longitude: number;
  address: string;
  confidence: number;
}

interface DistrictLookupResult {
  found: boolean;
  district?: DistrictBoundary;
  confidence: number;
  method: &apos;geometry&apos; | &apos;bbox&apos; | &apos;census_api&apos; | &apos;fallback&apos;;
  geocoded?: GeocodeResult;
  error?: string;
}

class DistrictLookupService {
  private initialized = false;

  async initialize(): Promise&lt;void&gt; {
    if (this.initialized) return;

    try {
      await districtBoundaryService.initialize();
      this.initialized = true;
    } catch (error) {
      logger.error(&apos;Failed to initialize district lookup service&apos;, error as Error, {
        service: &apos;DistrictLookupService&apos;,
      });
      throw error;
    }
  }

  /**
   * Find congressional district by latitude and longitude coordinates
   */
  async findDistrictByCoordinates(
    latitude: number,
    longitude: number
  ): Promise&lt;DistrictLookupResult&gt; {
    if (!this.initialized) {
      await this.initialize();
    }

    try {
      // Validate coordinates
      if (!this.isValidCoordinate(latitude, longitude)) {
        return {
          found: false,
          confidence: 0,
          method: &apos;fallback&apos;,
          error: &apos;Invalid coordinates&apos;,
        };
      }

      // Use district boundary service for point-in-district lookup
      const result = await districtBoundaryService.findDistrictByPoint(latitude, longitude);

      return {
        found: result.found,
        district: result.district,
        confidence: result.confidence,
        method: result.method === &apos;pmtiles&apos; ? &apos;geometry&apos; : result.method,
      };
    } catch (error) {
      logger.error(&apos;Error in district coordinate lookup&apos;, error as Error, {
        latitude,
        longitude,
        service: &apos;DistrictLookupService&apos;,
      });

      return {
        found: false,
        confidence: 0,
        method: &apos;fallback&apos;,
        error: &apos;Lookup failed&apos;,
      };
    }
  }

  /**
   * Find congressional district by ZIP code using existing ZIP-to-district mapping
   */
  async findDistrictByZipCode(zipCode: string): Promise&lt;DistrictLookupResult&gt; {
    if (!this.initialized) {
      await this.initialize();
    }

    try {
      // Use existing ZIP code API
      const response = await fetch(`/api/districts?zip=${zipCode}`);
      if (!response.ok) {
        throw new Error(`ZIP lookup failed: ${response.status}`);
      }

      const data = await response.json();

      if (!data.districts || data.districts.length === 0) {
        return {
          found: false,
          confidence: 0,
          method: &apos;fallback&apos;,
          error: &apos;No districts found for ZIP code&apos;,
        };
      }

      // Get the first district and enhance with boundary data
      const apiDistrict = data.districts[0];
      const districtId = `${apiDistrict.stateFips}-${apiDistrict.districtNumber.toString().padStart(2, &apos;0&apos;)}`;
      const district = districtBoundaryService.getDistrictById(districtId);

      if (district) {
        return {
          found: true,
          district,
          confidence: 0.95,
          method: &apos;census_api&apos;,
        };
      }

      // Fallback: create district boundary from API data
      const fallbackDistrict: DistrictBoundary = {
        id: districtId,
        state_fips: apiDistrict.stateFips,
        state_name: apiDistrict.stateName,
        state_abbr: apiDistrict.stateAbbr,
        district_num: apiDistrict.districtNumber.toString().padStart(2, &apos;0&apos;),
        name: `${apiDistrict.stateAbbr}-${apiDistrict.districtNumber.toString().padStart(2, &apos;0&apos;)}`,
        full_name: `${apiDistrict.stateName} Congressional District ${apiDistrict.districtNumber}`,
        centroid: [apiDistrict.longitude || -95.7129, apiDistrict.latitude || 37.0902],
        bbox: [
          (apiDistrict.longitude || -95.7129) - 1,
          (apiDistrict.latitude || 37.0902) - 1,
          (apiDistrict.longitude || -95.7129) + 1,
          (apiDistrict.latitude || 37.0902) + 1,
        ],
        area_sqm: 0,
        geoid: districtId,
      };

      return {
        found: true,
        district: fallbackDistrict,
        confidence: 0.8,
        method: &apos;census_api&apos;,
      };
    } catch (error) {
      logger.error(&apos;Error in district ZIP lookup&apos;, error as Error, {
        zipCode,
        service: &apos;DistrictLookupService&apos;,
      });

      return {
        found: false,
        confidence: 0,
        method: &apos;fallback&apos;,
        error: &apos;ZIP lookup failed&apos;,
      };
    }
  }

  /**
   * Find congressional district by address using geocoding
   */
  async findDistrictByAddress(address: string): Promise&lt;DistrictLookupResult&gt; {
    if (!this.initialized) {
      await this.initialize();
    }

    try {
      // First, try to geocode the address using Census Geocoding API
      const geocodeResult = await this.geocodeAddress(address);

      if (!geocodeResult) {
        return {
          found: false,
          confidence: 0,
          method: &apos;fallback&apos;,
          error: &apos;Address geocoding failed&apos;,
        };
      }

      // Use the geocoded coordinates to find the district
      const districtResult = await this.findDistrictByCoordinates(
        geocodeResult.latitude,
        geocodeResult.longitude
      );

      return {
        ...districtResult,
        geocoded: geocodeResult,
      };
    } catch (error) {
      logger.error(&apos;Error in district address lookup&apos;, error as Error, {
        address,
        service: &apos;DistrictLookupService&apos;,
      });

      return {
        found: false,
        confidence: 0,
        method: &apos;fallback&apos;,
        error: &apos;Address lookup failed&apos;,
      };
    }
  }

  /**
   * Get districts within a geographic bounding box
   */
  async getDistrictsInBounds(
    minLatitude: number,
    minLongitude: number,
    maxLatitude: number,
    maxLongitude: number
  ): Promise&lt;DistrictBoundary[]&gt; {
    if (!this.initialized) {
      await this.initialize();
    }

    return districtBoundaryService.getDistrictsInBounds(
      minLatitude,
      minLongitude,
      maxLatitude,
      maxLongitude
    );
  }

  /**
   * Search districts by name, state, or other criteria
   */
  async searchDistricts(query: string): Promise&lt;DistrictBoundary[]&gt; {
    if (!this.initialized) {
      await this.initialize();
    }

    return districtBoundaryService.searchDistricts(query);
  }

  /**
   * Geocode an address using Census Geocoding API
   */
  private async geocodeAddress(address: string): Promise&lt;GeocodeResult | null&gt; {
    try {
      // Use Census Bureau&apos;s Geocoding Services
      // https://geocoding.geo.census.gov/geocoder/Geocoding_Services_API.html
      const baseUrl = &apos;https://geocoding.geo.census.gov/geocoder/locations/onelineaddress&apos;;
      const params = new URLSearchParams({
        address: address,
        benchmark: &apos;Public_AR_Current&apos;,
        format: &apos;json&apos;,
      });

      const response = await fetch(`${baseUrl}?${params}`);
      if (!response.ok) {
        throw new Error(`Geocoding API error: ${response.status}`);
      }

      const data = await response.json();

      if (!data.result?.addressMatches?.[0]) {
        return null;
      }

      const match = data.result.addressMatches[0];
      const coordinates = match.coordinates;

      return {
        latitude: coordinates.y,
        longitude: coordinates.x,
        address: match.formattedAddress || address,
        confidence: match.tigerLine?.score || 0.8,
      };
    } catch (error) {
      logger.error(&apos;Geocoding failed&apos;, error as Error, {
        address,
        service: &apos;DistrictLookupService&apos;,
      });
      return null;
    }
  }

  /**
   * Validate if coordinates are within reasonable bounds for US
   */
  private isValidCoordinate(latitude: number, longitude: number): boolean {
    // US bounds (including Alaska and Hawaii)
    const US_BOUNDS = {
      minLat: 18.9, // Southernmost point (Hawaii)
      maxLat: 71.4, // Northernmost point (Alaska)
      minLng: -179.2, // Westernmost point (Alaska)
      maxLng: -66.9, // Easternmost point (Maine)
    };

    return (
      latitude &gt;= US_BOUNDS.minLat &amp;&amp;
      latitude &lt;= US_BOUNDS.maxLat &amp;&amp;
      longitude &gt;= US_BOUNDS.minLng &amp;&amp;
      longitude &lt;= US_BOUNDS.maxLng
    );
  }

  /**
   * Get detailed information about a district
   */
  async getDistrictDetails(districtId: string): Promise&lt;DistrictBoundary | null&gt; {
    if (!this.initialized) {
      await this.initialize();
    }

    return districtBoundaryService.getDistrictById(districtId);
  }

  /**
   * Get all districts for a state
   */
  async getStateDistricts(stateFips: string): Promise&lt;DistrictBoundary[]&gt; {
    if (!this.initialized) {
      await this.initialize();
    }

    return districtBoundaryService.getDistrictsByState(stateFips);
  }

  /**
   * Get summary statistics about the district data
   */
  async getSummary() {
    if (!this.initialized) {
      await this.initialize();
    }

    return districtBoundaryService.getSummary();
  }
}

// Create singleton instance
export const districtLookupService = new DistrictLookupService();

// Export types
export type { DistrictLookupResult, GeocodeResult };

/**
 * Convenience function for coordinate-based district lookup
 */
export async function findDistrictByCoordinates(
  latitude: number,
  longitude: number
): Promise&lt;DistrictLookupResult&gt; {
  return districtLookupService.findDistrictByCoordinates(latitude, longitude);
}

/**
 * Convenience function for ZIP code-based district lookup
 */
export async function findDistrictByZipCode(zipCode: string): Promise&lt;DistrictLookupResult&gt; {
  return districtLookupService.findDistrictByZipCode(zipCode);
}

/**
 * Convenience function for address-based district lookup
 */
export async function findDistrictByAddress(address: string): Promise&lt;DistrictLookupResult&gt; {
  return districtLookupService.findDistrictByAddress(address);
}

</file>
<file path="index.ts">
/**
 * Copyright (c) 2019-2025 Mark Sandford
 * Licensed under the MIT License. See LICENSE and NOTICE files.
 */

// API Services
export { representativesService } from &apos;./api/representatives.service&apos;;
export { newsService } from &apos;./api/news.service&apos;;

// Cache Services
export { redisService } from &apos;./cache/redis.service&apos;;

// AI Services
export { summarizationService } from &apos;./ai/summarization.service&apos;;

// Types
export type { CacheOperationResult } from &apos;./cache/redis.service&apos;;
export type {
  BillSummary,
  BillSummarizationOptions,
  MultiFormatSummary,
} from &apos;./ai/summarization.service&apos;;
export type {
  NewsArticle,
  NewsSearchOptions,
  BreakingNewsAlert,
  NewsSearchResult,
} from &apos;./api/news.service&apos;;
export type {
  RepresentativeFilters,
  RepresentativesBatchRequest,
  VotingRecord,
  CampaignFinance,
  PartyAlignment,
} from &apos;./api/representatives.service&apos;;

</file>
</codebase>